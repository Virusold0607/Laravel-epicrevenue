{"version":3,"sources":["select.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ui-select.js","sourcesContent":["/*!\r\n * ui-select\r\n * http://github.com/angular-ui/ui-select\r\n * Version: 0.13.2 - 2015-10-09T15:34:24.040Z\r\n * License: MIT\r\n */\r\n\r\n\r\n(function () { \r\n\"use strict\";\r\n\r\nvar KEY = {\r\n    TAB: 9,\r\n    ENTER: 13,\r\n    ESC: 27,\r\n    SPACE: 32,\r\n    LEFT: 37,\r\n    UP: 38,\r\n    RIGHT: 39,\r\n    DOWN: 40,\r\n    SHIFT: 16,\r\n    CTRL: 17,\r\n    ALT: 18,\r\n    PAGE_UP: 33,\r\n    PAGE_DOWN: 34,\r\n    HOME: 36,\r\n    END: 35,\r\n    BACKSPACE: 8,\r\n    DELETE: 46,\r\n    COMMAND: 91,\r\n\r\n    MAP: { 91 : \"COMMAND\", 8 : \"BACKSPACE\" , 9 : \"TAB\" , 13 : \"ENTER\" , 16 : \"SHIFT\" , 17 : \"CTRL\" , 18 : \"ALT\" , 19 : \"PAUSEBREAK\" , 20 : \"CAPSLOCK\" , 27 : \"ESC\" , 32 : \"SPACE\" , 33 : \"PAGE_UP\", 34 : \"PAGE_DOWN\" , 35 : \"END\" , 36 : \"HOME\" , 37 : \"LEFT\" , 38 : \"UP\" , 39 : \"RIGHT\" , 40 : \"DOWN\" , 43 : \"+\" , 44 : \"PRINTSCREEN\" , 45 : \"INSERT\" , 46 : \"DELETE\", 48 : \"0\" , 49 : \"1\" , 50 : \"2\" , 51 : \"3\" , 52 : \"4\" , 53 : \"5\" , 54 : \"6\" , 55 : \"7\" , 56 : \"8\" , 57 : \"9\" , 59 : \";\", 61 : \"=\" , 65 : \"A\" , 66 : \"B\" , 67 : \"C\" , 68 : \"D\" , 69 : \"E\" , 70 : \"F\" , 71 : \"G\" , 72 : \"H\" , 73 : \"I\" , 74 : \"J\" , 75 : \"K\" , 76 : \"L\", 77 : \"M\" , 78 : \"N\" , 79 : \"O\" , 80 : \"P\" , 81 : \"Q\" , 82 : \"R\" , 83 : \"S\" , 84 : \"T\" , 85 : \"U\" , 86 : \"V\" , 87 : \"W\" , 88 : \"X\" , 89 : \"Y\" , 90 : \"Z\", 96 : \"0\" , 97 : \"1\" , 98 : \"2\" , 99 : \"3\" , 100 : \"4\" , 101 : \"5\" , 102 : \"6\" , 103 : \"7\" , 104 : \"8\" , 105 : \"9\", 106 : \"*\" , 107 : \"+\" , 109 : \"-\" , 110 : \".\" , 111 : \"/\", 112 : \"F1\" , 113 : \"F2\" , 114 : \"F3\" , 115 : \"F4\" , 116 : \"F5\" , 117 : \"F6\" , 118 : \"F7\" , 119 : \"F8\" , 120 : \"F9\" , 121 : \"F10\" , 122 : \"F11\" , 123 : \"F12\", 144 : \"NUMLOCK\" , 145 : \"SCROLLLOCK\" , 186 : \";\" , 187 : \"=\" , 188 : \",\" , 189 : \"-\" , 190 : \".\" , 191 : \"/\" , 192 : \"`\" , 219 : \"[\" , 220 : \"\\\\\" , 221 : \"]\" , 222 : \"'\"\r\n    },\r\n\r\n    isControl: function (e) {\r\n        var k = e.which;\r\n        switch (k) {\r\n        case KEY.COMMAND:\r\n        case KEY.SHIFT:\r\n        case KEY.CTRL:\r\n        case KEY.ALT:\r\n            return true;\r\n        }\r\n\r\n        if (e.metaKey) return true;\r\n\r\n        return false;\r\n    },\r\n    isFunctionKey: function (k) {\r\n        k = k.which ? k.which : k;\r\n        return k >= 112 && k <= 123;\r\n    },\r\n    isVerticalMovement: function (k){\r\n      return ~[KEY.UP, KEY.DOWN].indexOf(k);\r\n    },\r\n    isHorizontalMovement: function (k){\r\n      return ~[KEY.LEFT,KEY.RIGHT,KEY.BACKSPACE,KEY.DELETE].indexOf(k);\r\n    }\r\n  };\r\n\r\n/**\r\n * Add querySelectorAll() to jqLite.\r\n *\r\n * jqLite find() is limited to lookups by tag name.\r\n * TODO This will change with future versions of AngularJS, to be removed when this happens\r\n *\r\n * See jqLite.find - why not use querySelectorAll? https://github.com/angular/angular.js/issues/3586\r\n * See feat(jqLite): use querySelectorAll instead of getElementsByTagName in jqLite.find https://github.com/angular/angular.js/pull/3598\r\n */\r\nif (angular.element.prototype.querySelectorAll === undefined) {\r\n  angular.element.prototype.querySelectorAll = function(selector) {\r\n    return angular.element(this[0].querySelectorAll(selector));\r\n  };\r\n}\r\n\r\n/**\r\n * Add closest() to jqLite.\r\n */\r\nif (angular.element.prototype.closest === undefined) {\r\n  angular.element.prototype.closest = function( selector) {\r\n    var elem = this[0];\r\n    var matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;\r\n\r\n    while (elem) {\r\n      if (matchesSelector.bind(elem)(selector)) {\r\n        return elem;\r\n      } else {\r\n        elem = elem.parentElement;\r\n      }\r\n    }\r\n    return false;\r\n  };\r\n}\r\n\r\nvar latestId = 0;\r\n\r\nvar uis = angular.module('ui.select', [])\r\n\r\n.constant('uiSelectConfig', {\r\n  theme: 'bootstrap',\r\n  searchEnabled: true,\r\n  sortable: false,\r\n  placeholder: '', // Empty by default, like HTML tag <select>\r\n  refreshDelay: 1000, // In milliseconds\r\n  closeOnSelect: true,\r\n  dropdownPosition: 'auto',\r\n  generateId: function() {\r\n    return latestId++;\r\n  },\r\n  appendToBody: false\r\n})\r\n\r\n// See Rename minErr and make it accessible from outside https://github.com/angular/angular.js/issues/6913\r\n.service('uiSelectMinErr', function() {\r\n  var minErr = angular.$$minErr('ui.select');\r\n  return function() {\r\n    var error = minErr.apply(this, arguments);\r\n    var message = error.message.replace(new RegExp('\\nhttp://errors.angularjs.org/.*'), '');\r\n    return new Error(message);\r\n  };\r\n})\r\n\r\n// Recreates old behavior of ng-transclude. Used internally.\r\n.directive('uisTranscludeAppend', function () {\r\n  return {\r\n    link: function (scope, element, attrs, ctrl, transclude) {\r\n        transclude(scope, function (clone) {\r\n          element.append(clone);\r\n        });\r\n      }\r\n    };\r\n})\r\n\r\n/**\r\n * Highlights text that matches $select.search.\r\n *\r\n * Taken from AngularUI Bootstrap Typeahead\r\n * See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L340\r\n */\r\n.filter('highlight', function() {\r\n  function escapeRegexp(queryToEscape) {\r\n    return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\r\n  }\r\n\r\n  return function(matchItem, query) {\r\n    return query && matchItem ? matchItem.replace(new RegExp(escapeRegexp(query), 'gi'), '<span class=\"ui-select-highlight\">$&</span>') : matchItem;\r\n  };\r\n})\r\n\r\n/**\r\n * A read-only equivalent of jQuery's offset function: http://api.jquery.com/offset/\r\n *\r\n * Taken from AngularUI Bootstrap Position:\r\n * See https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js#L70\r\n */\r\n.factory('uisOffset',\r\n  ['$document', '$window',\r\n  function ($document, $window) {\r\n\r\n  return function(element) {\r\n    var boundingClientRect = element[0].getBoundingClientRect();\r\n    return {\r\n      width: boundingClientRect.width || element.prop('offsetWidth'),\r\n      height: boundingClientRect.height || element.prop('offsetHeight'),\r\n      top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\r\n      left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\r\n    };\r\n  };\r\n}]);\r\n\r\nuis.directive('uiSelectChoices',\r\n  ['uiSelectConfig', 'uisRepeatParser', 'uiSelectMinErr', '$compile',\r\n  function(uiSelectConfig, RepeatParser, uiSelectMinErr, $compile) {\r\n\r\n  return {\r\n    restrict: 'EA',\r\n    require: '^uiSelect',\r\n    replace: true,\r\n    transclude: true,\r\n    templateUrl: function(tElement) {\r\n      // Gets theme attribute from parent (ui-select)\r\n      var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;\r\n      return theme + '/choices.tpl.html';\r\n    },\r\n\r\n    compile: function(tElement, tAttrs) {\r\n\r\n      if (!tAttrs.repeat) throw uiSelectMinErr('repeat', \"Expected 'repeat' expression.\");\r\n\r\n      return function link(scope, element, attrs, $select, transcludeFn) {\r\n\r\n        // var repeat = RepeatParser.parse(attrs.repeat);\r\n        var groupByExp = attrs.groupBy;\r\n        var groupFilterExp = attrs.groupFilter;\r\n\r\n        $select.parseRepeatAttr(attrs.repeat, groupByExp, groupFilterExp); //Result ready at $select.parserResult\r\n\r\n        $select.disableChoiceExpression = attrs.uiDisableChoice;\r\n        $select.onHighlightCallback = attrs.onHighlight;\r\n\r\n        $select.dropdownPosition = attrs.position ? attrs.position.toLowerCase() : uiSelectConfig.dropdownPosition;\r\n\r\n        if(groupByExp) {\r\n          var groups = element.querySelectorAll('.ui-select-choices-group');\r\n          if (groups.length !== 1) throw uiSelectMinErr('rows', \"Expected 1 .ui-select-choices-group but got '{0}'.\", groups.length);\r\n          groups.attr('ng-repeat', RepeatParser.getGroupNgRepeatExpression());\r\n        }\r\n\r\n        var choices = element.querySelectorAll('.ui-select-choices-row');\r\n        if (choices.length !== 1) {\r\n          throw uiSelectMinErr('rows', \"Expected 1 .ui-select-choices-row but got '{0}'.\", choices.length);\r\n        }\r\n\r\n        choices.attr('ng-repeat', $select.parserResult.repeatExpression(groupByExp))\r\n            .attr('ng-if', '$select.open') //Prevent unnecessary watches when dropdown is closed\r\n            .attr('ng-click', '$select.select(' + $select.parserResult.itemName + ',false,$event)');\r\n\r\n        var rowsInner = element.querySelectorAll('.ui-select-choices-row-inner');\r\n        if (rowsInner.length !== 1) throw uiSelectMinErr('rows', \"Expected 1 .ui-select-choices-row-inner but got '{0}'.\", rowsInner.length);\r\n        rowsInner.attr('uis-transclude-append', ''); //Adding uisTranscludeAppend directive to row element after choices element has ngRepeat\r\n\r\n        $compile(element, transcludeFn)(scope); //Passing current transcludeFn to be able to append elements correctly from uisTranscludeAppend\r\n\r\n        scope.$watch('$select.search', function(newValue) {\r\n          if(newValue && !$select.open && $select.multiple) $select.activate(false, true);\r\n          $select.activeIndex = $select.tagging.isActivated ? -1 : 0;\r\n          $select.refresh(attrs.refresh);\r\n        });\r\n\r\n        attrs.$observe('refreshDelay', function() {\r\n          // $eval() is needed otherwise we get a string instead of a number\r\n          var refreshDelay = scope.$eval(attrs.refreshDelay);\r\n          $select.refreshDelay = refreshDelay !== undefined ? refreshDelay : uiSelectConfig.refreshDelay;\r\n        });\r\n      };\r\n    }\r\n  };\r\n}]);\r\n\r\n/**\r\n * Contains ui-select \"intelligence\".\r\n *\r\n * The goal is to limit dependency on the DOM whenever possible and\r\n * put as much logic in the controller (instead of the link functions) as possible so it can be easily tested.\r\n */\r\nuis.controller('uiSelectCtrl',\r\n  ['$scope', '$element', '$timeout', '$filter', 'uisRepeatParser', 'uiSelectMinErr', 'uiSelectConfig', '$parse',\r\n  function($scope, $element, $timeout, $filter, RepeatParser, uiSelectMinErr, uiSelectConfig, $parse) {\r\n\r\n  var ctrl = this;\r\n\r\n  var EMPTY_SEARCH = '';\r\n\r\n  ctrl.placeholder = uiSelectConfig.placeholder;\r\n  ctrl.searchEnabled = uiSelectConfig.searchEnabled;\r\n  ctrl.sortable = uiSelectConfig.sortable;\r\n  ctrl.refreshDelay = uiSelectConfig.refreshDelay;\r\n\r\n  ctrl.removeSelected = false; //If selected item(s) should be removed from dropdown list\r\n  ctrl.closeOnSelect = true; //Initialized inside uiSelect directive link function\r\n  ctrl.search = EMPTY_SEARCH;\r\n\r\n  ctrl.activeIndex = 0; //Dropdown of choices\r\n  ctrl.items = []; //All available choices\r\n\r\n  ctrl.open = false;\r\n  ctrl.focus = false;\r\n  ctrl.disabled = false;\r\n  ctrl.selected = undefined;\r\n\r\n  ctrl.dropdownPosition = 'auto';\r\n\r\n  ctrl.focusser = undefined; //Reference to input element used to handle focus events\r\n  ctrl.resetSearchInput = true;\r\n  ctrl.multiple = undefined; // Initialized inside uiSelect directive link function\r\n  ctrl.disableChoiceExpression = undefined; // Initialized inside uiSelectChoices directive link function\r\n  ctrl.tagging = {isActivated: false, fct: undefined};\r\n  ctrl.taggingTokens = {isActivated: false, tokens: undefined};\r\n  ctrl.lockChoiceExpression = undefined; // Initialized inside uiSelectMatch directive link function\r\n  ctrl.clickTriggeredSelect = false;\r\n  ctrl.$filter = $filter;\r\n\r\n  ctrl.searchInput = $element.querySelectorAll('input.ui-select-search');\r\n  if (ctrl.searchInput.length !== 1) {\r\n    throw uiSelectMinErr('searchInput', \"Expected 1 input.ui-select-search but got '{0}'.\", ctrl.searchInput.length);\r\n  }\r\n  \r\n  ctrl.isEmpty = function() {\r\n    return angular.isUndefined(ctrl.selected) || ctrl.selected === null || ctrl.selected === '';\r\n  };\r\n\r\n  // Most of the time the user does not want to empty the search input when in typeahead mode\r\n  function _resetSearchInput() {\r\n    if (ctrl.resetSearchInput || (ctrl.resetSearchInput === undefined && uiSelectConfig.resetSearchInput)) {\r\n      ctrl.search = EMPTY_SEARCH;\r\n      //reset activeIndex\r\n      if (ctrl.selected && ctrl.items.length && !ctrl.multiple) {\r\n        ctrl.activeIndex = ctrl.items.indexOf(ctrl.selected);\r\n      }\r\n    }\r\n  }\r\n\r\n    function _groupsFilter(groups, groupNames) {\r\n      var i, j, result = [];\r\n      for(i = 0; i < groupNames.length ;i++){\r\n        for(j = 0; j < groups.length ;j++){\r\n          if(groups[j].name == [groupNames[i]]){\r\n            result.push(groups[j]);\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n  // When the user clicks on ui-select, displays the dropdown list\r\n  ctrl.activate = function(initSearchValue, avoidReset) {\r\n    if (!ctrl.disabled  && !ctrl.open) {\r\n      if(!avoidReset) _resetSearchInput();\r\n\r\n      $scope.$broadcast('uis:activate');\r\n\r\n      ctrl.open = true;\r\n\r\n      ctrl.activeIndex = ctrl.activeIndex >= ctrl.items.length ? 0 : ctrl.activeIndex;\r\n\r\n      // ensure that the index is set to zero for tagging variants\r\n      // that where first option is auto-selected\r\n      if ( ctrl.activeIndex === -1 && ctrl.taggingLabel !== false ) {\r\n        ctrl.activeIndex = 0;\r\n      }\r\n\r\n      // Give it time to appear before focus\r\n      $timeout(function() {\r\n        ctrl.search = initSearchValue || ctrl.search;\r\n        ctrl.searchInput[0].focus();\r\n        if(!ctrl.tagging.isActivated && ctrl.items.length > 1) {\r\n          _ensureHighlightVisible();\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  ctrl.findGroupByName = function(name) {\r\n    return ctrl.groups && ctrl.groups.filter(function(group) {\r\n      return group.name === name;\r\n    })[0];\r\n  };\r\n\r\n  ctrl.parseRepeatAttr = function(repeatAttr, groupByExp, groupFilterExp) {\r\n    function updateGroups(items) {\r\n      var groupFn = $scope.$eval(groupByExp);\r\n      ctrl.groups = [];\r\n      angular.forEach(items, function(item) {\r\n        var groupName = angular.isFunction(groupFn) ? groupFn(item) : item[groupFn];\r\n        var group = ctrl.findGroupByName(groupName);\r\n        if(group) {\r\n          group.items.push(item);\r\n        }\r\n        else {\r\n          ctrl.groups.push({name: groupName, items: [item]});\r\n        }\r\n      });\r\n      if(groupFilterExp){\r\n        var groupFilterFn = $scope.$eval(groupFilterExp);\r\n        if( angular.isFunction(groupFilterFn)){\r\n          ctrl.groups = groupFilterFn(ctrl.groups);\r\n        } else if(angular.isArray(groupFilterFn)){\r\n          ctrl.groups = _groupsFilter(ctrl.groups, groupFilterFn);\r\n        }\r\n      }\r\n      ctrl.items = [];\r\n      ctrl.groups.forEach(function(group) {\r\n        ctrl.items = ctrl.items.concat(group.items);\r\n      });\r\n    }\r\n\r\n    function setPlainItems(items) {\r\n      ctrl.items = items;\r\n    }\r\n\r\n    ctrl.setItemsFn = groupByExp ? updateGroups : setPlainItems;\r\n\r\n    ctrl.parserResult = RepeatParser.parse(repeatAttr);\r\n\r\n    ctrl.isGrouped = !!groupByExp;\r\n    ctrl.itemProperty = ctrl.parserResult.itemName;\r\n\r\n    //If collection is an Object, convert it to Array\r\n\r\n    var originalSource = ctrl.parserResult.source;\r\n    \r\n    //When an object is used as source, we better create an array and use it as 'source'\r\n    var createArrayFromObject = function(){\r\n      var origSrc = originalSource($scope);\r\n      $scope.$uisSource = Object.keys(origSrc).map(function(v){\r\n        var result = {};\r\n        result[ctrl.parserResult.keyName] = v;\r\n        result.value = origSrc[v];\r\n        return result;\r\n      });\r\n    };\r\n\r\n    if (ctrl.parserResult.keyName){ // Check for (key,value) syntax\r\n      createArrayFromObject();\r\n      ctrl.parserResult.source = $parse('$uisSource' + ctrl.parserResult.filters);\r\n      $scope.$watch(originalSource, function(newVal, oldVal){\r\n        if (newVal !== oldVal) createArrayFromObject();\r\n      }, true);\r\n    }\r\n\r\n    ctrl.refreshItems = function (data){\r\n      data = data || ctrl.parserResult.source($scope);\r\n      var selectedItems = ctrl.selected;\r\n      //TODO should implement for single mode removeSelected\r\n      if (ctrl.isEmpty() || (angular.isArray(selectedItems) && !selectedItems.length) || !ctrl.removeSelected) {\r\n        ctrl.setItemsFn(data);\r\n      }else{\r\n        if ( data !== undefined ) {\r\n          var filteredItems = data.filter(function(i) {return selectedItems && selectedItems.indexOf(i) < 0;});\r\n          ctrl.setItemsFn(filteredItems);\r\n        }\r\n      }\r\n      if (ctrl.dropdownPosition === 'auto' || ctrl.dropdownPosition === 'up'){\r\n        $scope.calculateDropdownPos();\r\n      }\r\n    };\r\n\r\n    // See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L259\r\n    $scope.$watchCollection(ctrl.parserResult.source, function(items) {\r\n      if (items === undefined || items === null) {\r\n        // If the user specifies undefined or null => reset the collection\r\n        // Special case: items can be undefined if the user did not initialized the collection on the scope\r\n        // i.e $scope.addresses = [] is missing\r\n        ctrl.items = [];\r\n      } else {\r\n        if (!angular.isArray(items)) {\r\n          throw uiSelectMinErr('items', \"Expected an array but got '{0}'.\", items);          \r\n        } else {\r\n          //Remove already selected items (ex: while searching)\r\n          //TODO Should add a test\r\n          ctrl.refreshItems(items);\r\n          ctrl.ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters\r\n        }\r\n      }\r\n    });\r\n\r\n  };\r\n\r\n  var _refreshDelayPromise;\r\n\r\n  /**\r\n   * Typeahead mode: lets the user refresh the collection using his own function.\r\n   *\r\n   * See Expose $select.search for external / remote filtering https://github.com/angular-ui/ui-select/pull/31\r\n   */\r\n  ctrl.refresh = function(refreshAttr) {\r\n    if (refreshAttr !== undefined) {\r\n\r\n      // Debounce\r\n      // See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L155\r\n      // FYI AngularStrap typeahead does not have debouncing: https://github.com/mgcrea/angular-strap/blob/v2.0.0-rc.4/src/typeahead/typeahead.js#L177\r\n      if (_refreshDelayPromise) {\r\n        $timeout.cancel(_refreshDelayPromise);\r\n      }\r\n      _refreshDelayPromise = $timeout(function() {\r\n        $scope.$eval(refreshAttr);\r\n      }, ctrl.refreshDelay);\r\n    }\r\n  };\r\n\r\n  ctrl.isActive = function(itemScope) {\r\n    if ( !ctrl.open ) {\r\n      return false;\r\n    }\r\n    var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);\r\n    var isActive =  itemIndex === ctrl.activeIndex;\r\n\r\n    if ( !isActive || ( itemIndex < 0 && ctrl.taggingLabel !== false ) ||( itemIndex < 0 && ctrl.taggingLabel === false) ) {\r\n      return false;\r\n    }\r\n\r\n    if (isActive && !angular.isUndefined(ctrl.onHighlightCallback)) {\r\n      itemScope.$eval(ctrl.onHighlightCallback);\r\n    }\r\n\r\n    return isActive;\r\n  };\r\n\r\n  ctrl.isDisabled = function(itemScope) {\r\n\r\n    if (!ctrl.open) return;\r\n\r\n    var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);\r\n    var isDisabled = false;\r\n    var item;\r\n\r\n    if (itemIndex >= 0 && !angular.isUndefined(ctrl.disableChoiceExpression)) {\r\n      item = ctrl.items[itemIndex];\r\n      isDisabled = !!(itemScope.$eval(ctrl.disableChoiceExpression)); // force the boolean value\r\n      item._uiSelectChoiceDisabled = isDisabled; // store this for later reference\r\n    }\r\n\r\n    return isDisabled;\r\n  };\r\n\r\n\r\n  // When the user selects an item with ENTER or clicks the dropdown\r\n  ctrl.select = function(item, skipFocusser, $event) {\r\n    if (item === undefined || !item._uiSelectChoiceDisabled) {\r\n\r\n      if ( ! ctrl.items && ! ctrl.search ) return;\r\n\r\n      if (!item || !item._uiSelectChoiceDisabled) {\r\n        if(ctrl.tagging.isActivated) {\r\n          // if taggingLabel is disabled, we pull from ctrl.search val\r\n          if ( ctrl.taggingLabel === false ) {\r\n            if ( ctrl.activeIndex < 0 ) {\r\n              item = ctrl.tagging.fct !== undefined ? ctrl.tagging.fct(ctrl.search) : ctrl.search;\r\n              if (!item || angular.equals( ctrl.items[0], item ) ) {\r\n                return;\r\n              }\r\n            } else {\r\n              // keyboard nav happened first, user selected from dropdown\r\n              item = ctrl.items[ctrl.activeIndex];\r\n            }\r\n          } else {\r\n            // tagging always operates at index zero, taggingLabel === false pushes\r\n            // the ctrl.search value without having it injected\r\n            if ( ctrl.activeIndex === 0 ) {\r\n              // ctrl.tagging pushes items to ctrl.items, so we only have empty val\r\n              // for `item` if it is a detected duplicate\r\n              if ( item === undefined ) return;\r\n\r\n              // create new item on the fly if we don't already have one;\r\n              // use tagging function if we have one\r\n              if ( ctrl.tagging.fct !== undefined && typeof item === 'string' ) {\r\n                item = ctrl.tagging.fct(ctrl.search);\r\n                if (!item) return;\r\n              // if item type is 'string', apply the tagging label\r\n              } else if ( typeof item === 'string' ) {\r\n                // trim the trailing space\r\n                item = item.replace(ctrl.taggingLabel,'').trim();\r\n              }\r\n            }\r\n          }\r\n          // search ctrl.selected for dupes potentially caused by tagging and return early if found\r\n          if ( ctrl.selected && angular.isArray(ctrl.selected) && ctrl.selected.filter( function (selection) { return angular.equals(selection, item); }).length > 0 ) {\r\n            ctrl.close(skipFocusser);\r\n            return;\r\n          }\r\n        }\r\n\r\n        $scope.$broadcast('uis:select', item);\r\n\r\n        var locals = {};\r\n        locals[ctrl.parserResult.itemName] = item;\r\n\r\n        $timeout(function(){\r\n          ctrl.onSelectCallback($scope, {\r\n            $item: item,\r\n            $model: ctrl.parserResult.modelMapper($scope, locals)\r\n          });\r\n        });\r\n\r\n        if (ctrl.closeOnSelect) {\r\n          ctrl.close(skipFocusser);\r\n        }\r\n        if ($event && $event.type === 'click') {\r\n          ctrl.clickTriggeredSelect = true;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // Closes the dropdown\r\n  ctrl.close = function(skipFocusser) {\r\n    if (!ctrl.open) return;\r\n    if (ctrl.ngModel && ctrl.ngModel.$setTouched) ctrl.ngModel.$setTouched();\r\n    _resetSearchInput();\r\n    ctrl.open = false;\r\n\r\n    $scope.$broadcast('uis:close', skipFocusser);\r\n\r\n  };\r\n\r\n  ctrl.setFocus = function(){\r\n    if (!ctrl.focus) ctrl.focusInput[0].focus();\r\n  };\r\n\r\n  ctrl.clear = function($event) {\r\n    ctrl.select(undefined);\r\n    $event.stopPropagation();\r\n    $timeout(function() {\r\n      ctrl.focusser[0].focus();\r\n    }, 0, false);\r\n  };\r\n\r\n  // Toggle dropdown\r\n  ctrl.toggle = function(e) {\r\n    if (ctrl.open) {\r\n      ctrl.close();\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n    } else {\r\n      ctrl.activate();\r\n    }\r\n  };\r\n\r\n  ctrl.isLocked = function(itemScope, itemIndex) {\r\n      var isLocked, item = ctrl.selected[itemIndex];\r\n\r\n      if (item && !angular.isUndefined(ctrl.lockChoiceExpression)) {\r\n          isLocked = !!(itemScope.$eval(ctrl.lockChoiceExpression)); // force the boolean value\r\n          item._uiSelectChoiceLocked = isLocked; // store this for later reference\r\n      }\r\n\r\n      return isLocked;\r\n  };\r\n\r\n  var sizeWatch = null;\r\n  ctrl.sizeSearchInput = function() {\r\n\r\n    var input = ctrl.searchInput[0],\r\n        container = ctrl.searchInput.parent().parent()[0],\r\n        calculateContainerWidth = function() {\r\n          // Return the container width only if the search input is visible\r\n          return container.clientWidth * !!input.offsetParent;\r\n        },\r\n        updateIfVisible = function(containerWidth) {\r\n          if (containerWidth === 0) {\r\n            return false;\r\n          }\r\n          var inputWidth = containerWidth - input.offsetLeft - 10;\r\n          if (inputWidth < 50) inputWidth = containerWidth;\r\n          ctrl.searchInput.css('width', inputWidth+'px');\r\n          return true;\r\n        };\r\n\r\n    ctrl.searchInput.css('width', '10px');\r\n    $timeout(function() { //Give tags time to render correctly\r\n      if (sizeWatch === null && !updateIfVisible(calculateContainerWidth())) {\r\n        sizeWatch = $scope.$watch(calculateContainerWidth, function(containerWidth) {\r\n          if (updateIfVisible(containerWidth)) {\r\n            sizeWatch();\r\n            sizeWatch = null;\r\n          }\r\n        });\r\n      }\r\n    });\r\n  };\r\n\r\n  function _handleDropDownSelection(key) {\r\n    var processed = true;\r\n    switch (key) {\r\n      case KEY.DOWN:\r\n        if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode\r\n        else if (ctrl.activeIndex < ctrl.items.length - 1) { ctrl.activeIndex++; }\r\n        break;\r\n      case KEY.UP:\r\n        if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode\r\n        else if (ctrl.activeIndex > 0 || (ctrl.search.length === 0 && ctrl.tagging.isActivated && ctrl.activeIndex > -1)) { ctrl.activeIndex--; }\r\n        break;\r\n      case KEY.TAB:\r\n        if (!ctrl.multiple || ctrl.open) ctrl.select(ctrl.items[ctrl.activeIndex], true);\r\n        break;\r\n      case KEY.ENTER:\r\n        if(ctrl.open && (ctrl.tagging.isActivated || ctrl.activeIndex >= 0)){\r\n          ctrl.select(ctrl.items[ctrl.activeIndex]); // Make sure at least one dropdown item is highlighted before adding if not in tagging mode\r\n        } else {\r\n          ctrl.activate(false, true); //In case its the search input in 'multiple' mode\r\n        }\r\n        break;\r\n      case KEY.ESC:\r\n        ctrl.close();\r\n        break;\r\n      default:\r\n        processed = false;\r\n    }\r\n    return processed;\r\n  }\r\n\r\n  // Bind to keyboard shortcuts\r\n  ctrl.searchInput.on('keydown', function(e) {\r\n\r\n    var key = e.which;\r\n\r\n    // if(~[KEY.ESC,KEY.TAB].indexOf(key)){\r\n    //   //TODO: SEGURO?\r\n    //   ctrl.close();\r\n    // }\r\n\r\n    $scope.$apply(function() {\r\n\r\n      var tagged = false;\r\n\r\n      if (ctrl.items.length > 0 || ctrl.tagging.isActivated) {\r\n        _handleDropDownSelection(key);\r\n        if ( ctrl.taggingTokens.isActivated ) {\r\n          for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {\r\n            if ( ctrl.taggingTokens.tokens[i] === KEY.MAP[e.keyCode] ) {\r\n              // make sure there is a new value to push via tagging\r\n              if ( ctrl.search.length > 0 ) {\r\n                tagged = true;\r\n              }\r\n            }\r\n          }\r\n          if ( tagged ) {\r\n            $timeout(function() {\r\n              ctrl.searchInput.triggerHandler('tagged');\r\n              var newItem = ctrl.search.replace(KEY.MAP[e.keyCode],'').trim();\r\n              if ( ctrl.tagging.fct ) {\r\n                newItem = ctrl.tagging.fct( newItem );\r\n              }\r\n              if (newItem) ctrl.select(newItem, true);\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n    });\r\n\r\n    if(KEY.isVerticalMovement(key) && ctrl.items.length > 0){\r\n      _ensureHighlightVisible();\r\n    }\r\n\r\n    if (key === KEY.ENTER || key === KEY.ESC) {\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n    }\r\n\r\n  });\r\n\r\n  // If tagging try to split by tokens and add items\r\n  ctrl.searchInput.on('paste', function (e) {\r\n    var data = e.originalEvent.clipboardData.getData('text/plain');\r\n    if (data && data.length > 0 && ctrl.taggingTokens.isActivated && ctrl.tagging.fct) {\r\n      var items = data.split(ctrl.taggingTokens.tokens[0]); // split by first token only\r\n      if (items && items.length > 0) {\r\n        angular.forEach(items, function (item) {\r\n          var newItem = ctrl.tagging.fct(item);\r\n          if (newItem) {\r\n            ctrl.select(newItem, true);\r\n          }\r\n        });\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n      }\r\n    }\r\n  });\r\n\r\n  ctrl.searchInput.on('tagged', function() {\r\n    $timeout(function() {\r\n      _resetSearchInput();\r\n    });\r\n  });\r\n\r\n  // See https://github.com/ivaynberg/select2/blob/3.4.6/select2.js#L1431\r\n  function _ensureHighlightVisible() {\r\n    var container = $element.querySelectorAll('.ui-select-choices-content');\r\n    var choices = container.querySelectorAll('.ui-select-choices-row');\r\n    if (choices.length < 1) {\r\n      throw uiSelectMinErr('choices', \"Expected multiple .ui-select-choices-row but got '{0}'.\", choices.length);\r\n    }\r\n\r\n    if (ctrl.activeIndex < 0) {\r\n      return;\r\n    }\r\n\r\n    var highlighted = choices[ctrl.activeIndex];\r\n    var posY = highlighted.offsetTop + highlighted.clientHeight - container[0].scrollTop;\r\n    var height = container[0].offsetHeight;\r\n\r\n    if (posY > height) {\r\n      container[0].scrollTop += posY - height;\r\n    } else if (posY < highlighted.clientHeight) {\r\n      if (ctrl.isGrouped && ctrl.activeIndex === 0)\r\n        container[0].scrollTop = 0; //To make group header visible when going all the way up\r\n      else\r\n        container[0].scrollTop -= highlighted.clientHeight - posY;\r\n    }\r\n  }\r\n\r\n  $scope.$on('$destroy', function() {\r\n    ctrl.searchInput.off('keyup keydown tagged blur paste');\r\n  });\r\n\r\n}]);\r\n\r\nuis.directive('uiSelect',\r\n  ['$document', 'uiSelectConfig', 'uiSelectMinErr', 'uisOffset', '$compile', '$parse', '$timeout',\r\n  function($document, uiSelectConfig, uiSelectMinErr, uisOffset, $compile, $parse, $timeout) {\r\n\r\n  return {\r\n    restrict: 'EA',\r\n    templateUrl: function(tElement, tAttrs) {\r\n      var theme = tAttrs.theme || uiSelectConfig.theme;\r\n      return theme + (angular.isDefined(tAttrs.multiple) ? '/select-multiple.tpl.html' : '/select.tpl.html');\r\n    },\r\n    replace: true,\r\n    transclude: true,\r\n    require: ['uiSelect', '^ngModel'],\r\n    scope: true,\r\n\r\n    controller: 'uiSelectCtrl',\r\n    controllerAs: '$select',\r\n    compile: function(tElement, tAttrs) {\r\n\r\n      //Multiple or Single depending if multiple attribute presence\r\n      if (angular.isDefined(tAttrs.multiple))\r\n        tElement.append('<ui-select-multiple/>').removeAttr('multiple');\r\n      else\r\n        tElement.append('<ui-select-single/>');\r\n\r\n      if (tAttrs.inputId)\r\n        tElement.querySelectorAll('input.ui-select-search')[0].id = tAttrs.inputId;\r\n\r\n      return function(scope, element, attrs, ctrls, transcludeFn) {\r\n\r\n        var $select = ctrls[0];\r\n        var ngModel = ctrls[1];\r\n\r\n        $select.generatedId = uiSelectConfig.generateId();\r\n        $select.baseTitle = attrs.title || 'Select box';\r\n        $select.focusserTitle = $select.baseTitle + ' focus';\r\n        $select.focusserId = 'focusser-' + $select.generatedId;\r\n\r\n        $select.closeOnSelect = function() {\r\n          if (angular.isDefined(attrs.closeOnSelect)) {\r\n            return $parse(attrs.closeOnSelect)();\r\n          } else {\r\n            return uiSelectConfig.closeOnSelect;\r\n          }\r\n        }();\r\n\r\n        $select.onSelectCallback = $parse(attrs.onSelect);\r\n        $select.onRemoveCallback = $parse(attrs.onRemove);\r\n\r\n        //Limit the number of selections allowed\r\n        $select.limit = (angular.isDefined(attrs.limit)) ? parseInt(attrs.limit, 10) : undefined;\r\n\r\n        //Set reference to ngModel from uiSelectCtrl\r\n        $select.ngModel = ngModel;\r\n\r\n        $select.choiceGrouped = function(group){\r\n          return $select.isGrouped && group && group.name;\r\n        };\r\n\r\n        if(attrs.tabindex){\r\n          attrs.$observe('tabindex', function(value) {\r\n            $select.focusInput.attr('tabindex', value);\r\n            element.removeAttr('tabindex');\r\n          });\r\n        }\r\n\r\n        scope.$watch('searchEnabled', function() {\r\n            var searchEnabled = scope.$eval(attrs.searchEnabled);\r\n            $select.searchEnabled = searchEnabled !== undefined ? searchEnabled : uiSelectConfig.searchEnabled;\r\n        });\r\n\r\n        scope.$watch('sortable', function() {\r\n            var sortable = scope.$eval(attrs.sortable);\r\n            $select.sortable = sortable !== undefined ? sortable : uiSelectConfig.sortable;\r\n        });\r\n\r\n        attrs.$observe('disabled', function() {\r\n          // No need to use $eval() (thanks to ng-disabled) since we already get a boolean instead of a string\r\n          $select.disabled = attrs.disabled !== undefined ? attrs.disabled : false;\r\n        });\r\n\r\n        attrs.$observe('resetSearchInput', function() {\r\n          // $eval() is needed otherwise we get a string instead of a boolean\r\n          var resetSearchInput = scope.$eval(attrs.resetSearchInput);\r\n          $select.resetSearchInput = resetSearchInput !== undefined ? resetSearchInput : true;\r\n        });\r\n\r\n        attrs.$observe('tagging', function() {\r\n          if(attrs.tagging !== undefined)\r\n          {\r\n            // $eval() is needed otherwise we get a string instead of a boolean\r\n            var taggingEval = scope.$eval(attrs.tagging);\r\n            $select.tagging = {isActivated: true, fct: taggingEval !== true ? taggingEval : undefined};\r\n          }\r\n          else\r\n          {\r\n            $select.tagging = {isActivated: false, fct: undefined};\r\n          }\r\n        });\r\n\r\n        attrs.$observe('taggingLabel', function() {\r\n          if(attrs.tagging !== undefined )\r\n          {\r\n            // check eval for FALSE, in this case, we disable the labels\r\n            // associated with tagging\r\n            if ( attrs.taggingLabel === 'false' ) {\r\n              $select.taggingLabel = false;\r\n            }\r\n            else\r\n            {\r\n              $select.taggingLabel = attrs.taggingLabel !== undefined ? attrs.taggingLabel : '(new)';\r\n            }\r\n          }\r\n        });\r\n\r\n        attrs.$observe('taggingTokens', function() {\r\n          if (attrs.tagging !== undefined) {\r\n            var tokens = attrs.taggingTokens !== undefined ? attrs.taggingTokens.split('|') : [',','ENTER'];\r\n            $select.taggingTokens = {isActivated: true, tokens: tokens };\r\n          }\r\n        });\r\n\r\n        //Automatically gets focus when loaded\r\n        if (angular.isDefined(attrs.autofocus)){\r\n          $timeout(function(){\r\n            $select.setFocus();\r\n          });\r\n        }\r\n\r\n        //Gets focus based on scope event name (e.g. focus-on='SomeEventName')\r\n        if (angular.isDefined(attrs.focusOn)){\r\n          scope.$on(attrs.focusOn, function() {\r\n              $timeout(function(){\r\n                $select.setFocus();\r\n              });\r\n          });\r\n        }\r\n\r\n        function onDocumentClick(e) {\r\n          if (!$select.open) return; //Skip it if dropdown is close\r\n\r\n          var contains = false;\r\n\r\n          if (window.jQuery) {\r\n            // Firefox 3.6 does not support element.contains()\r\n            // See Node.contains https://developer.mozilla.org/en-US/docs/Web/API/Node.contains\r\n            contains = window.jQuery.contains(element[0], e.target);\r\n          } else {\r\n            contains = element[0].contains(e.target);\r\n          }\r\n\r\n          if (!contains && !$select.clickTriggeredSelect) {\r\n            //Will lose focus only with certain targets\r\n            var focusableControls = ['input','button','textarea'];\r\n            var targetController = angular.element(e.target).controller('uiSelect'); //To check if target is other ui-select\r\n            var skipFocusser = targetController && targetController !== $select; //To check if target is other ui-select\r\n            if (!skipFocusser) skipFocusser =  ~focusableControls.indexOf(e.target.tagName.toLowerCase()); //Check if target is input, button or textarea\r\n            $select.close(skipFocusser);\r\n            scope.$digest();\r\n          }\r\n          $select.clickTriggeredSelect = false;\r\n        }\r\n\r\n        // See Click everywhere but here event http://stackoverflow.com/questions/12931369\r\n        $document.on('click', onDocumentClick);\r\n\r\n        scope.$on('$destroy', function() {\r\n          $document.off('click', onDocumentClick);\r\n        });\r\n\r\n        // Move transcluded elements to their correct position in main template\r\n        transcludeFn(scope, function(clone) {\r\n          // See Transclude in AngularJS http://blog.omkarpatil.com/2012/11/transclude-in-angularjs.html\r\n\r\n          // One day jqLite will be replaced by jQuery and we will be able to write:\r\n          // var transcludedElement = clone.filter('.my-class')\r\n          // instead of creating a hackish DOM element:\r\n          var transcluded = angular.element('<div>').append(clone);\r\n\r\n          var transcludedMatch = transcluded.querySelectorAll('.ui-select-match');\r\n          transcludedMatch.removeAttr('ui-select-match'); //To avoid loop in case directive as attr\r\n          transcludedMatch.removeAttr('data-ui-select-match'); // Properly handle HTML5 data-attributes\r\n          if (transcludedMatch.length !== 1) {\r\n            throw uiSelectMinErr('transcluded', \"Expected 1 .ui-select-match but got '{0}'.\", transcludedMatch.length);\r\n          }\r\n          element.querySelectorAll('.ui-select-match').replaceWith(transcludedMatch);\r\n\r\n          var transcludedChoices = transcluded.querySelectorAll('.ui-select-choices');\r\n          transcludedChoices.removeAttr('ui-select-choices'); //To avoid loop in case directive as attr\r\n          transcludedChoices.removeAttr('data-ui-select-choices'); // Properly handle HTML5 data-attributes\r\n          if (transcludedChoices.length !== 1) {\r\n            throw uiSelectMinErr('transcluded', \"Expected 1 .ui-select-choices but got '{0}'.\", transcludedChoices.length);\r\n          }\r\n          element.querySelectorAll('.ui-select-choices').replaceWith(transcludedChoices);\r\n        });\r\n\r\n        // Support for appending the select field to the body when its open\r\n        var appendToBody = scope.$eval(attrs.appendToBody);\r\n        if (appendToBody !== undefined ? appendToBody : uiSelectConfig.appendToBody) {\r\n          scope.$watch('$select.open', function(isOpen) {\r\n            if (isOpen) {\r\n              positionDropdown();\r\n            } else {\r\n              resetDropdown();\r\n            }\r\n          });\r\n\r\n          // Move the dropdown back to its original location when the scope is destroyed. Otherwise\r\n          // it might stick around when the user routes away or the select field is otherwise removed\r\n          scope.$on('$destroy', function() {\r\n            resetDropdown();\r\n          });\r\n        }\r\n\r\n        // Hold on to a reference to the .ui-select-container element for appendToBody support\r\n        var placeholder = null,\r\n            originalWidth = '';\r\n\r\n        function positionDropdown() {\r\n          // Remember the absolute position of the element\r\n          var offset = uisOffset(element);\r\n\r\n          // Clone the element into a placeholder element to take its original place in the DOM\r\n          placeholder = angular.element('<div class=\"ui-select-placeholder\"></div>');\r\n          placeholder[0].style.width = offset.width + 'px';\r\n          placeholder[0].style.height = offset.height + 'px';\r\n          element.after(placeholder);\r\n\r\n          // Remember the original value of the element width inline style, so it can be restored\r\n          // when the dropdown is closed\r\n          originalWidth = element[0].style.width;\r\n\r\n          // Now move the actual dropdown element to the end of the body\r\n          $document.find('body').append(element);\r\n\r\n          element[0].style.position = 'absolute';\r\n          element[0].style.left = offset.left + 'px';\r\n          element[0].style.top = offset.top + 'px';\r\n          element[0].style.width = offset.width + 'px';\r\n        }\r\n\r\n        function resetDropdown() {\r\n          if (placeholder === null) {\r\n            // The dropdown has not actually been display yet, so there's nothing to reset\r\n            return;\r\n          }\r\n\r\n          // Move the dropdown element back to its original location in the DOM\r\n          placeholder.replaceWith(element);\r\n          placeholder = null;\r\n\r\n          element[0].style.position = '';\r\n          element[0].style.left = '';\r\n          element[0].style.top = '';\r\n          element[0].style.width = originalWidth;\r\n        }\r\n\r\n        // Hold on to a reference to the .ui-select-dropdown element for direction support.\r\n        var dropdown = null,\r\n            directionUpClassName = 'direction-up';\r\n\r\n        // Support changing the direction of the dropdown if there isn't enough space to render it.\r\n        scope.$watch('$select.open', function() {\r\n\r\n          if ($select.dropdownPosition === 'auto' || $select.dropdownPosition === 'up'){\r\n            scope.calculateDropdownPos();\r\n          }\r\n\r\n        });\r\n\r\n        var setDropdownPosUp = function(offset, offsetDropdown){\r\n\r\n          offset = offset || uisOffset(element);\r\n          offsetDropdown = offsetDropdown || uisOffset(dropdown);\r\n\r\n          dropdown[0].style.position = 'absolute';\r\n          dropdown[0].style.top = (offsetDropdown.height * -1) + 'px';\r\n          element.addClass(directionUpClassName);\r\n\r\n        };\r\n\r\n        var setDropdownPosDown = function(offset, offsetDropdown){\r\n\r\n          element.removeClass(directionUpClassName);\r\n\r\n          offset = offset || uisOffset(element);\r\n          offsetDropdown = offsetDropdown || uisOffset(dropdown);\r\n\r\n          dropdown[0].style.position = '';\r\n          dropdown[0].style.top = '';\r\n\r\n        };\r\n\r\n        scope.calculateDropdownPos = function(){\r\n\r\n          if ($select.open) {\r\n            dropdown = angular.element(element).querySelectorAll('.ui-select-dropdown');\r\n            if (dropdown.length === 0) {\r\n              return;\r\n            }\r\n\r\n            // Hide the dropdown so there is no flicker until $timeout is done executing.\r\n            dropdown[0].style.opacity = 0;\r\n\r\n            // Delay positioning the dropdown until all choices have been added so its height is correct.\r\n            $timeout(function(){\r\n\r\n              if ($select.dropdownPosition === 'up'){\r\n                  //Go UP\r\n                  setDropdownPosUp(offset, offsetDropdown);\r\n\r\n              }else{ //AUTO\r\n\r\n                element.removeClass(directionUpClassName);\r\n\r\n                var offset = uisOffset(element);\r\n                var offsetDropdown = uisOffset(dropdown);\r\n\r\n                //https://code.google.com/p/chromium/issues/detail?id=342307#c4\r\n                var scrollTop = $document[0].documentElement.scrollTop || $document[0].body.scrollTop; //To make it cross browser (blink, webkit, IE, Firefox).\r\n\r\n                // Determine if the direction of the dropdown needs to be changed.\r\n                if (offset.top + offset.height + offsetDropdown.height > scrollTop + $document[0].documentElement.clientHeight) {\r\n                  //Go UP\r\n                  setDropdownPosUp(offset, offsetDropdown);\r\n                }else{\r\n                  //Go DOWN\r\n                  setDropdownPosDown(offset, offsetDropdown);\r\n                }\r\n\r\n              }\r\n\r\n              // Display the dropdown once it has been positioned.\r\n              dropdown[0].style.opacity = 1;\r\n            });\r\n          } else {\r\n              if (dropdown === null || dropdown.length === 0) {\r\n                return;\r\n              }\r\n\r\n              // Reset the position of the dropdown.\r\n              dropdown[0].style.position = '';\r\n              dropdown[0].style.top = '';\r\n              element.removeClass(directionUpClassName);\r\n          }\r\n        };\r\n      };\r\n    }\r\n  };\r\n}]);\r\n\r\nuis.directive('uiSelectMatch', ['uiSelectConfig', function(uiSelectConfig) {\r\n  return {\r\n    restrict: 'EA',\r\n    require: '^uiSelect',\r\n    replace: true,\r\n    transclude: true,\r\n    templateUrl: function(tElement) {\r\n      // Gets theme attribute from parent (ui-select)\r\n      var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;\r\n      var multi = tElement.parent().attr('multiple');\r\n      return theme + (multi ? '/match-multiple.tpl.html' : '/match.tpl.html');\r\n    },\r\n    link: function(scope, element, attrs, $select) {\r\n      $select.lockChoiceExpression = attrs.uiLockChoice;\r\n      attrs.$observe('placeholder', function(placeholder) {\r\n        $select.placeholder = placeholder !== undefined ? placeholder : uiSelectConfig.placeholder;\r\n      });\r\n\r\n      function setAllowClear(allow) {\r\n        $select.allowClear = (angular.isDefined(allow)) ? (allow === '') ? true : (allow.toLowerCase() === 'true') : false;\r\n      }\r\n\r\n      attrs.$observe('allowClear', setAllowClear);\r\n      setAllowClear(attrs.allowClear);\r\n\r\n      if($select.multiple){\r\n        $select.sizeSearchInput();\r\n      }\r\n\r\n    }\r\n  };\r\n}]);\r\n\r\nuis.directive('uiSelectMultiple', ['uiSelectMinErr','$timeout', function(uiSelectMinErr, $timeout) {\r\n  return {\r\n    restrict: 'EA',\r\n    require: ['^uiSelect', '^ngModel'],\r\n\r\n    controller: ['$scope','$timeout', function($scope, $timeout){\r\n\r\n      var ctrl = this,\r\n          $select = $scope.$select,\r\n          ngModel;\r\n\r\n      //Wait for link fn to inject it \r\n      $scope.$evalAsync(function(){ ngModel = $scope.ngModel; });\r\n\r\n      ctrl.activeMatchIndex = -1;\r\n\r\n      ctrl.updateModel = function(){\r\n        ngModel.$setViewValue(Date.now()); //Set timestamp as a unique string to force changes\r\n        ctrl.refreshComponent();\r\n      };\r\n\r\n      ctrl.refreshComponent = function(){\r\n        //Remove already selected items\r\n        //e.g. When user clicks on a selection, the selected array changes and \r\n        //the dropdown should remove that item\r\n        $select.refreshItems();\r\n        $select.sizeSearchInput();\r\n      };\r\n\r\n      // Remove item from multiple select\r\n      ctrl.removeChoice = function(index){\r\n\r\n        var removedChoice = $select.selected[index];\r\n\r\n        // if the choice is locked, can't remove it\r\n        if(removedChoice._uiSelectChoiceLocked) return;\r\n\r\n        var locals = {};\r\n        locals[$select.parserResult.itemName] = removedChoice;\r\n\r\n        $select.selected.splice(index, 1);\r\n        ctrl.activeMatchIndex = -1;\r\n        $select.sizeSearchInput();\r\n\r\n        // Give some time for scope propagation.\r\n        $timeout(function(){\r\n          $select.onRemoveCallback($scope, {\r\n            $item: removedChoice,\r\n            $model: $select.parserResult.modelMapper($scope, locals)\r\n          });\r\n        });\r\n\r\n        ctrl.updateModel();\r\n\r\n      };\r\n\r\n      ctrl.getPlaceholder = function(){\r\n        //Refactor single?\r\n        if($select.selected && $select.selected.length) return;\r\n        return $select.placeholder;\r\n      };\r\n\r\n\r\n    }],\r\n    controllerAs: '$selectMultiple',\r\n\r\n    link: function(scope, element, attrs, ctrls) {\r\n\r\n      var $select = ctrls[0];\r\n      var ngModel = scope.ngModel = ctrls[1];\r\n      var $selectMultiple = scope.$selectMultiple;\r\n\r\n      //$select.selected = raw selected objects (ignoring any property binding)\r\n\r\n      $select.multiple = true;\r\n      $select.removeSelected = true;\r\n\r\n      //Input that will handle focus\r\n      $select.focusInput = $select.searchInput;\r\n\r\n      //From view --> model\r\n      ngModel.$parsers.unshift(function () {\r\n        var locals = {},\r\n            result,\r\n            resultMultiple = [];\r\n        for (var j = $select.selected.length - 1; j >= 0; j--) {\r\n          locals = {};\r\n          locals[$select.parserResult.itemName] = $select.selected[j];\r\n          result = $select.parserResult.modelMapper(scope, locals);\r\n          resultMultiple.unshift(result);\r\n        }\r\n        return resultMultiple;\r\n      });\r\n\r\n      // From model --> view\r\n      ngModel.$formatters.unshift(function (inputValue) {\r\n        var data = $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search\r\n            locals = {},\r\n            result;\r\n        if (!data) return inputValue;\r\n        var resultMultiple = [];\r\n        var checkFnMultiple = function(list, value){\r\n          if (!list || !list.length) return;\r\n          for (var p = list.length - 1; p >= 0; p--) {\r\n            locals[$select.parserResult.itemName] = list[p];\r\n            result = $select.parserResult.modelMapper(scope, locals);\r\n            if($select.parserResult.trackByExp){\r\n                var matches = /\\.(.+)/.exec($select.parserResult.trackByExp);\r\n                if(matches.length>0 && result[matches[1]] == value[matches[1]]){\r\n                    resultMultiple.unshift(list[p]);\r\n                    return true;\r\n                }\r\n            }\r\n            if (angular.equals(result,value)){\r\n              resultMultiple.unshift(list[p]);\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        };\r\n        if (!inputValue) return resultMultiple; //If ngModel was undefined\r\n        for (var k = inputValue.length - 1; k >= 0; k--) {\r\n          //Check model array of currently selected items \r\n          if (!checkFnMultiple($select.selected, inputValue[k])){\r\n            //Check model array of all items available\r\n            if (!checkFnMultiple(data, inputValue[k])){\r\n              //If not found on previous lists, just add it directly to resultMultiple\r\n              resultMultiple.unshift(inputValue[k]);\r\n            }\r\n          }\r\n        }\r\n        return resultMultiple;\r\n      });\r\n      \r\n      //Watch for external model changes \r\n      scope.$watchCollection(function(){ return ngModel.$modelValue; }, function(newValue, oldValue) {\r\n        if (oldValue != newValue){\r\n          ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters\r\n          $selectMultiple.refreshComponent();\r\n        }\r\n      });\r\n\r\n      ngModel.$render = function() {\r\n        // Make sure that model value is array\r\n        if(!angular.isArray(ngModel.$viewValue)){\r\n          // Have tolerance for null or undefined values\r\n          if(angular.isUndefined(ngModel.$viewValue) || ngModel.$viewValue === null){\r\n            $select.selected = [];\r\n          } else {\r\n            throw uiSelectMinErr('multiarr', \"Expected model value to be array but got '{0}'\", ngModel.$viewValue);\r\n          }\r\n        }\r\n        $select.selected = ngModel.$viewValue;\r\n        scope.$evalAsync(); //To force $digest\r\n      };\r\n\r\n      scope.$on('uis:select', function (event, item) {\r\n        if($select.selected.length >= $select.limit) {\r\n          return;\r\n        }\r\n        $select.selected.push(item);\r\n        $selectMultiple.updateModel();\r\n      });\r\n\r\n      scope.$on('uis:activate', function () {\r\n        $selectMultiple.activeMatchIndex = -1;\r\n      });\r\n\r\n      scope.$watch('$select.disabled', function(newValue, oldValue) {\r\n        // As the search input field may now become visible, it may be necessary to recompute its size\r\n        if (oldValue && !newValue) $select.sizeSearchInput();\r\n      });\r\n\r\n      $select.searchInput.on('keydown', function(e) {\r\n        var key = e.which;\r\n        scope.$apply(function() {\r\n          var processed = false;\r\n          // var tagged = false; //Checkme\r\n          if(KEY.isHorizontalMovement(key)){\r\n            processed = _handleMatchSelection(key);\r\n          }\r\n          if (processed  && key != KEY.TAB) {\r\n            //TODO Check si el tab selecciona aun correctamente\r\n            //Crear test\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n          }\r\n        });\r\n      });\r\n      function _getCaretPosition(el) {\r\n        if(angular.isNumber(el.selectionStart)) return el.selectionStart;\r\n        // selectionStart is not supported in IE8 and we don't want hacky workarounds so we compromise\r\n        else return el.value.length;\r\n      }\r\n      // Handles selected options in \"multiple\" mode\r\n      function _handleMatchSelection(key){\r\n        var caretPosition = _getCaretPosition($select.searchInput[0]),\r\n            length = $select.selected.length,\r\n            // none  = -1,\r\n            first = 0,\r\n            last  = length-1,\r\n            curr  = $selectMultiple.activeMatchIndex,\r\n            next  = $selectMultiple.activeMatchIndex+1,\r\n            prev  = $selectMultiple.activeMatchIndex-1,\r\n            newIndex = curr;\r\n\r\n        if(caretPosition > 0 || ($select.search.length && key == KEY.RIGHT)) return false;\r\n\r\n        $select.close();\r\n\r\n        function getNewActiveMatchIndex(){\r\n          switch(key){\r\n            case KEY.LEFT:\r\n              // Select previous/first item\r\n              if(~$selectMultiple.activeMatchIndex) return prev;\r\n              // Select last item\r\n              else return last;\r\n              break;\r\n            case KEY.RIGHT:\r\n              // Open drop-down\r\n              if(!~$selectMultiple.activeMatchIndex || curr === last){\r\n                $select.activate();\r\n                return false;\r\n              }\r\n              // Select next/last item\r\n              else return next;\r\n              break;\r\n            case KEY.BACKSPACE:\r\n              // Remove selected item and select previous/first\r\n              if(~$selectMultiple.activeMatchIndex){\r\n                $selectMultiple.removeChoice(curr);\r\n                return prev;\r\n              }\r\n              // Select last item\r\n              else return last;\r\n              break;\r\n            case KEY.DELETE:\r\n              // Remove selected item and select next item\r\n              if(~$selectMultiple.activeMatchIndex){\r\n                $selectMultiple.removeChoice($selectMultiple.activeMatchIndex);\r\n                return curr;\r\n              }\r\n              else return false;\r\n          }\r\n        }\r\n\r\n        newIndex = getNewActiveMatchIndex();\r\n\r\n        if(!$select.selected.length || newIndex === false) $selectMultiple.activeMatchIndex = -1;\r\n        else $selectMultiple.activeMatchIndex = Math.min(last,Math.max(first,newIndex));\r\n\r\n        return true;\r\n      }\r\n\r\n      $select.searchInput.on('keyup', function(e) {\r\n\r\n        if ( ! KEY.isVerticalMovement(e.which) ) {\r\n          scope.$evalAsync( function () {\r\n            $select.activeIndex = $select.taggingLabel === false ? -1 : 0;\r\n          });\r\n        }\r\n        // Push a \"create new\" item into array if there is a search string\r\n        if ( $select.tagging.isActivated && $select.search.length > 0 ) {\r\n\r\n          // return early with these keys\r\n          if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || KEY.isVerticalMovement(e.which) ) {\r\n            return;\r\n          }\r\n          // always reset the activeIndex to the first item when tagging\r\n          $select.activeIndex = $select.taggingLabel === false ? -1 : 0;\r\n          // taggingLabel === false bypasses all of this\r\n          if ($select.taggingLabel === false) return;\r\n\r\n          var items = angular.copy( $select.items );\r\n          var stashArr = angular.copy( $select.items );\r\n          var newItem;\r\n          var item;\r\n          var hasTag = false;\r\n          var dupeIndex = -1;\r\n          var tagItems;\r\n          var tagItem;\r\n\r\n          // case for object tagging via transform `$select.tagging.fct` function\r\n          if ( $select.tagging.fct !== undefined) {\r\n            tagItems = $select.$filter('filter')(items,{'isTag': true});\r\n            if ( tagItems.length > 0 ) {\r\n              tagItem = tagItems[0];\r\n            }\r\n            // remove the first element, if it has the `isTag` prop we generate a new one with each keyup, shaving the previous\r\n            if ( items.length > 0 && tagItem ) {\r\n              hasTag = true;\r\n              items = items.slice(1,items.length);\r\n              stashArr = stashArr.slice(1,stashArr.length);\r\n            }\r\n            newItem = $select.tagging.fct($select.search);\r\n            newItem.isTag = true;\r\n            // verify the the tag doesn't match the value of an existing item\r\n            if ( stashArr.filter( function (origItem) { return angular.equals( origItem, $select.tagging.fct($select.search) ); } ).length > 0 ) {\r\n              return;\r\n            }\r\n            newItem.isTag = true;\r\n          // handle newItem string and stripping dupes in tagging string context\r\n          } else {\r\n            // find any tagging items already in the $select.items array and store them\r\n            tagItems = $select.$filter('filter')(items,function (item) {\r\n              return item.match($select.taggingLabel);\r\n            });\r\n            if ( tagItems.length > 0 ) {\r\n              tagItem = tagItems[0];\r\n            }\r\n            item = items[0];\r\n            // remove existing tag item if found (should only ever be one tag item)\r\n            if ( item !== undefined && items.length > 0 && tagItem ) {\r\n              hasTag = true;\r\n              items = items.slice(1,items.length);\r\n              stashArr = stashArr.slice(1,stashArr.length);\r\n            }\r\n            newItem = $select.search+' '+$select.taggingLabel;\r\n            if ( _findApproxDupe($select.selected, $select.search) > -1 ) {\r\n              return;\r\n            }\r\n            // verify the the tag doesn't match the value of an existing item from\r\n            // the searched data set or the items already selected\r\n            if ( _findCaseInsensitiveDupe(stashArr.concat($select.selected)) ) {\r\n              // if there is a tag from prev iteration, strip it / queue the change\r\n              // and return early\r\n              if ( hasTag ) {\r\n                items = stashArr;\r\n                scope.$evalAsync( function () {\r\n                  $select.activeIndex = 0;\r\n                  $select.items = items;\r\n                });\r\n              }\r\n              return;\r\n            }\r\n            if ( _findCaseInsensitiveDupe(stashArr) ) {\r\n              // if there is a tag from prev iteration, strip it\r\n              if ( hasTag ) {\r\n                $select.items = stashArr.slice(1,stashArr.length);\r\n              }\r\n              return;\r\n            }\r\n          }\r\n          if ( hasTag ) dupeIndex = _findApproxDupe($select.selected, newItem);\r\n          // dupe found, shave the first item\r\n          if ( dupeIndex > -1 ) {\r\n            items = items.slice(dupeIndex+1,items.length-1);\r\n          } else {\r\n            items = [];\r\n            items.push(newItem);\r\n            items = items.concat(stashArr);\r\n          }\r\n          scope.$evalAsync( function () {\r\n            $select.activeIndex = 0;\r\n            $select.items = items;\r\n          });\r\n        }\r\n      });\r\n      function _findCaseInsensitiveDupe(arr) {\r\n        if ( arr === undefined || $select.search === undefined ) {\r\n          return false;\r\n        }\r\n        var hasDupe = arr.filter( function (origItem) {\r\n          if ( $select.search.toUpperCase() === undefined || origItem === undefined ) {\r\n            return false;\r\n          }\r\n          return origItem.toUpperCase() === $select.search.toUpperCase();\r\n        }).length > 0;\r\n\r\n        return hasDupe;\r\n      }\r\n      function _findApproxDupe(haystack, needle) {\r\n        var dupeIndex = -1;\r\n        if(angular.isArray(haystack)) {\r\n          var tempArr = angular.copy(haystack);\r\n          for (var i = 0; i <tempArr.length; i++) {\r\n            // handle the simple string version of tagging\r\n            if ( $select.tagging.fct === undefined ) {\r\n              // search the array for the match\r\n              if ( tempArr[i]+' '+$select.taggingLabel === needle ) {\r\n              dupeIndex = i;\r\n              }\r\n            // handle the object tagging implementation\r\n            } else {\r\n              var mockObj = tempArr[i];\r\n              mockObj.isTag = true;\r\n              if ( angular.equals(mockObj, needle) ) {\r\n              dupeIndex = i;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return dupeIndex;\r\n      }\r\n\r\n      $select.searchInput.on('blur', function() {\r\n        $timeout(function() {\r\n          $selectMultiple.activeMatchIndex = -1;\r\n        });\r\n      });\r\n\r\n    }\r\n  };\r\n}]);\r\n\r\nuis.directive('uiSelectSingle', ['$timeout','$compile', function($timeout, $compile) {\r\n  return {\r\n    restrict: 'EA',\r\n    require: ['^uiSelect', '^ngModel'],\r\n    link: function(scope, element, attrs, ctrls) {\r\n\r\n      var $select = ctrls[0];\r\n      var ngModel = ctrls[1];\r\n\r\n      //From view --> model\r\n      ngModel.$parsers.unshift(function (inputValue) {\r\n        var locals = {},\r\n            result;\r\n        locals[$select.parserResult.itemName] = inputValue;\r\n        result = $select.parserResult.modelMapper(scope, locals);\r\n        return result;\r\n      });\r\n\r\n      //From model --> view\r\n      ngModel.$formatters.unshift(function (inputValue) {\r\n        var data = $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search\r\n            locals = {},\r\n            result;\r\n        if (data){\r\n          var checkFnSingle = function(d){\r\n            locals[$select.parserResult.itemName] = d;\r\n            result = $select.parserResult.modelMapper(scope, locals);\r\n            return result == inputValue;\r\n          };\r\n          //If possible pass same object stored in $select.selected\r\n          if ($select.selected && checkFnSingle($select.selected)) {\r\n            return $select.selected;\r\n          }\r\n          for (var i = data.length - 1; i >= 0; i--) {\r\n            if (checkFnSingle(data[i])) return data[i];\r\n          }\r\n        }\r\n        return inputValue;\r\n      });\r\n\r\n      //Update viewValue if model change\r\n      scope.$watch('$select.selected', function(newValue) {\r\n        if (ngModel.$viewValue !== newValue) {\r\n          ngModel.$setViewValue(newValue);\r\n        }\r\n      });\r\n\r\n      ngModel.$render = function() {\r\n        $select.selected = ngModel.$viewValue;\r\n      };\r\n\r\n      scope.$on('uis:select', function (event, item) {\r\n        $select.selected = item;\r\n      });\r\n\r\n      scope.$on('uis:close', function (event, skipFocusser) {\r\n        $timeout(function(){\r\n          $select.focusser.prop('disabled', false);\r\n          if (!skipFocusser) $select.focusser[0].focus();\r\n        },0,false);\r\n      });\r\n\r\n      scope.$on('uis:activate', function () {\r\n        focusser.prop('disabled', true); //Will reactivate it on .close()\r\n      });\r\n\r\n      //Idea from: https://github.com/ivaynberg/select2/blob/79b5bf6db918d7560bdd959109b7bcfb47edaf43/select2.js#L1954\r\n      var focusser = angular.element(\"<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />\");\r\n      $compile(focusser)(scope);\r\n      $select.focusser = focusser;\r\n\r\n      //Input that will handle focus\r\n      $select.focusInput = focusser;\r\n\r\n      element.parent().append(focusser);\r\n      focusser.bind(\"focus\", function(){\r\n        scope.$evalAsync(function(){\r\n          $select.focus = true;\r\n        });\r\n      });\r\n      focusser.bind(\"blur\", function(){\r\n        scope.$evalAsync(function(){\r\n          $select.focus = false;\r\n        });\r\n      });\r\n      focusser.bind(\"keydown\", function(e){\r\n\r\n        if (e.which === KEY.BACKSPACE) {\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n          $select.select(undefined);\r\n          scope.$apply();\r\n          return;\r\n        }\r\n\r\n        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {\r\n          return;\r\n        }\r\n\r\n        if (e.which == KEY.DOWN  || e.which == KEY.UP || e.which == KEY.ENTER || e.which == KEY.SPACE){\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n          $select.activate();\r\n        }\r\n\r\n        scope.$digest();\r\n      });\r\n\r\n      focusser.bind(\"keyup input\", function(e){\r\n\r\n        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || e.which == KEY.ENTER || e.which === KEY.BACKSPACE) {\r\n          return;\r\n        }\r\n\r\n        $select.activate(focusser.val()); //User pressed some regular key, so we pass it to the search input\r\n        focusser.val('');\r\n        scope.$digest();\r\n\r\n      });\r\n\r\n\r\n    }\r\n  };\r\n}]);\r\n// Make multiple matches sortable\r\nuis.directive('uiSelectSort', ['$timeout', 'uiSelectConfig', 'uiSelectMinErr', function($timeout, uiSelectConfig, uiSelectMinErr) {\r\n  return {\r\n    require: '^uiSelect',\r\n    link: function(scope, element, attrs, $select) {\r\n      if (scope[attrs.uiSelectSort] === null) {\r\n        throw uiSelectMinErr('sort', \"Expected a list to sort\");\r\n      }\r\n\r\n      var options = angular.extend({\r\n          axis: 'horizontal'\r\n        },\r\n        scope.$eval(attrs.uiSelectSortOptions));\r\n\r\n      var axis = options.axis,\r\n        draggingClassName = 'dragging',\r\n        droppingClassName = 'dropping',\r\n        droppingBeforeClassName = 'dropping-before',\r\n        droppingAfterClassName = 'dropping-after';\r\n\r\n      scope.$watch(function(){\r\n        return $select.sortable;\r\n      }, function(n){\r\n        if (n) {\r\n          element.attr('draggable', true);\r\n        } else {\r\n          element.removeAttr('draggable');\r\n        }\r\n      });\r\n\r\n      element.on('dragstart', function(e) {\r\n        element.addClass(draggingClassName);\r\n\r\n        (e.dataTransfer || e.originalEvent.dataTransfer).setData('text/plain', scope.$index);\r\n      });\r\n\r\n      element.on('dragend', function() {\r\n        element.removeClass(draggingClassName);\r\n      });\r\n\r\n      var move = function(from, to) {\r\n        /*jshint validthis: true */\r\n        this.splice(to, 0, this.splice(from, 1)[0]);\r\n      };\r\n\r\n      var dragOverHandler = function(e) {\r\n        e.preventDefault();\r\n\r\n        var offset = axis === 'vertical' ? e.offsetY || e.layerY || (e.originalEvent ? e.originalEvent.offsetY : 0) : e.offsetX || e.layerX || (e.originalEvent ? e.originalEvent.offsetX : 0);\r\n\r\n        if (offset < (this[axis === 'vertical' ? 'offsetHeight' : 'offsetWidth'] / 2)) {\r\n          element.removeClass(droppingAfterClassName);\r\n          element.addClass(droppingBeforeClassName);\r\n\r\n        } else {\r\n          element.removeClass(droppingBeforeClassName);\r\n          element.addClass(droppingAfterClassName);\r\n        }\r\n      };\r\n\r\n      var dropTimeout;\r\n\r\n      var dropHandler = function(e) {\r\n        e.preventDefault();\r\n\r\n        var droppedItemIndex = parseInt((e.dataTransfer || e.originalEvent.dataTransfer).getData('text/plain'), 10);\r\n\r\n        // prevent event firing multiple times in firefox\r\n        $timeout.cancel(dropTimeout);\r\n        dropTimeout = $timeout(function() {\r\n          _dropHandler(droppedItemIndex);\r\n        }, 20);\r\n      };\r\n\r\n      var _dropHandler = function(droppedItemIndex) {\r\n        var theList = scope.$eval(attrs.uiSelectSort),\r\n          itemToMove = theList[droppedItemIndex],\r\n          newIndex = null;\r\n\r\n        if (element.hasClass(droppingBeforeClassName)) {\r\n          if (droppedItemIndex < scope.$index) {\r\n            newIndex = scope.$index - 1;\r\n          } else {\r\n            newIndex = scope.$index;\r\n          }\r\n        } else {\r\n          if (droppedItemIndex < scope.$index) {\r\n            newIndex = scope.$index;\r\n          } else {\r\n            newIndex = scope.$index + 1;\r\n          }\r\n        }\r\n\r\n        move.apply(theList, [droppedItemIndex, newIndex]);\r\n\r\n        scope.$apply(function() {\r\n          scope.$emit('uiSelectSort:change', {\r\n            array: theList,\r\n            item: itemToMove,\r\n            from: droppedItemIndex,\r\n            to: newIndex\r\n          });\r\n        });\r\n\r\n        element.removeClass(droppingClassName);\r\n        element.removeClass(droppingBeforeClassName);\r\n        element.removeClass(droppingAfterClassName);\r\n\r\n        element.off('drop', dropHandler);\r\n      };\r\n\r\n      element.on('dragenter', function() {\r\n        if (element.hasClass(draggingClassName)) {\r\n          return;\r\n        }\r\n\r\n        element.addClass(droppingClassName);\r\n\r\n        element.on('dragover', dragOverHandler);\r\n        element.on('drop', dropHandler);\r\n      });\r\n\r\n      element.on('dragleave', function(e) {\r\n        if (e.target != element) {\r\n          return;\r\n        }\r\n        element.removeClass(droppingClassName);\r\n        element.removeClass(droppingBeforeClassName);\r\n        element.removeClass(droppingAfterClassName);\r\n\r\n        element.off('dragover', dragOverHandler);\r\n        element.off('drop', dropHandler);\r\n      });\r\n    }\r\n  };\r\n}]);\r\n\r\n/**\r\n * Parses \"repeat\" attribute.\r\n *\r\n * Taken from AngularJS ngRepeat source code\r\n * See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L211\r\n *\r\n * Original discussion about parsing \"repeat\" attribute instead of fully relying on ng-repeat:\r\n * https://github.com/angular-ui/ui-select/commit/5dd63ad#commitcomment-5504697\r\n */\r\n\r\nuis.service('uisRepeatParser', ['uiSelectMinErr','$parse', function(uiSelectMinErr, $parse) {\r\n  var self = this;\r\n\r\n  /**\r\n   * Example:\r\n   * expression = \"address in addresses | filter: {street: $select.search} track by $index\"\r\n   * itemName = \"address\",\r\n   * source = \"addresses | filter: {street: $select.search}\",\r\n   * trackByExp = \"$index\",\r\n   */\r\n  self.parse = function(expression) {\r\n\r\n\r\n    var match;\r\n    var isObjectCollection = /\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)/.test(expression);\r\n    // If an array is used as collection\r\n\r\n    // if (isObjectCollection){\r\n      //00000000000000000000000000000111111111000000000000000222222222222220033333333333333333333330000444444444444444444000000000000000556666660000077777777777755000000000000000000000088888880000000\r\n    match = expression.match(/^\\s*(?:([\\s\\S]+?)\\s+as\\s+)?(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(([\\w\\.]+)?\\s*(|\\s*[\\s\\S]+?))?(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/);      \r\n\r\n    // 1 Alias\r\n    // 2 Item\r\n    // 3 Key on (key,value)\r\n    // 4 Value on (key,value)\r\n    // 5 Collection expresion (only used when using an array collection)\r\n    // 6 Object that will be converted to Array when using (key,value) syntax\r\n    // 7 Filters that will be applied to #6 when using (key,value) syntax\r\n    // 8 Track by\r\n\r\n    if (!match) {\r\n      throw uiSelectMinErr('iexp', \"Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.\",\r\n              expression);\r\n    }\r\n    if (!match[6] && isObjectCollection) {\r\n      throw uiSelectMinErr('iexp', \"Expected expression in form of '_item_ as (_key_, _item_) in _ObjCollection_ [ track by _id_]' but got '{0}'.\",\r\n              expression);\r\n    }\r\n\r\n    return {\r\n      itemName: match[4] || match[2], // (lhs) Left-hand side,\r\n      keyName: match[3], //for (key, value) syntax\r\n      source: $parse(!match[3] ? match[5] : match[6]),\r\n      sourceName: match[6],\r\n      filters: match[7],\r\n      trackByExp: match[8],\r\n      modelMapper: $parse(match[1] || match[4] || match[2]),\r\n      repeatExpression: function (grouped) {\r\n        var expression = this.itemName + ' in ' + (grouped ? '$group.items' : '$select.items');\r\n        if (this.trackByExp) {\r\n          expression += ' track by ' + this.trackByExp;\r\n        }\r\n        return expression;\r\n      } \r\n    };\r\n\r\n  };\r\n\r\n  self.getGroupNgRepeatExpression = function() {\r\n    return '$group in $select.groups';\r\n  };\r\n\r\n}]);\r\n\r\n}());\r\nangular.module(\"ui.select\").run([\"$templateCache\", function($templateCache) {$templateCache.put(\"bootstrap/choices.tpl.html\",\"<ul class=\\\"ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu\\\" role=\\\"listbox\\\" ng-show=\\\"$select.items.length > 0\\\"><li class=\\\"ui-select-choices-group\\\" id=\\\"ui-select-choices-{{ $select.generatedId }}\\\"><div class=\\\"divider\\\" ng-show=\\\"$select.isGrouped && $index > 0\\\"></div><div ng-show=\\\"$select.isGrouped\\\" class=\\\"ui-select-choices-group-label dropdown-header\\\" ng-bind=\\\"$group.name\\\"></div><div id=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\\\" class=\\\"ui-select-choices-row\\\" ng-class=\\\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\\\" role=\\\"option\\\"><a href=\\\"javascript:void(0)\\\" class=\\\"ui-select-choices-row-inner\\\"></a></div></li></ul>\");\r\n$templateCache.put(\"bootstrap/match-multiple.tpl.html\",\"<span class=\\\"ui-select-match\\\"><span ng-repeat=\\\"$item in $select.selected\\\"><span class=\\\"ui-select-match-item btn btn-default btn-xs\\\" tabindex=\\\"-1\\\" type=\\\"button\\\" ng-disabled=\\\"$select.disabled\\\" ng-click=\\\"$selectMultiple.activeMatchIndex = $index;\\\" ng-class=\\\"{\\'btn-primary\\':$selectMultiple.activeMatchIndex === $index, \\'select-locked\\':$select.isLocked(this, $index)}\\\" ui-select-sort=\\\"$select.selected\\\"><span class=\\\"close ui-select-match-close\\\" ng-hide=\\\"$select.disabled\\\" ng-click=\\\"$selectMultiple.removeChoice($index)\\\">&nbsp;&times;</span> <span uis-transclude-append=\\\"\\\"></span></span></span></span>\");\r\n$templateCache.put(\"bootstrap/match.tpl.html\",\"<div class=\\\"ui-select-match\\\" ng-hide=\\\"$select.open\\\" ng-disabled=\\\"$select.disabled\\\" ng-class=\\\"{\\'btn-default-focus\\':$select.focus}\\\"><span tabindex=\\\"-1\\\" class=\\\"btn btn-default form-control ui-select-toggle\\\" aria-label=\\\"{{ $select.baseTitle }} activate\\\" ng-disabled=\\\"$select.disabled\\\" ng-click=\\\"$select.activate()\\\" style=\\\"outline: 0;\\\"><span ng-show=\\\"$select.isEmpty()\\\" class=\\\"ui-select-placeholder text-muted\\\">{{$select.placeholder}}</span> <span ng-hide=\\\"$select.isEmpty()\\\" class=\\\"ui-select-match-text pull-left\\\" ng-class=\\\"{\\'ui-select-allow-clear\\': $select.allowClear && !$select.isEmpty()}\\\" ng-transclude=\\\"\\\"></span> <i class=\\\"caret pull-right\\\" ng-click=\\\"$select.toggle($event)\\\"></i> <a ng-show=\\\"$select.allowClear && !$select.isEmpty()\\\" aria-label=\\\"{{ $select.baseTitle }} clear\\\" style=\\\"margin-right: 10px\\\" ng-click=\\\"$select.clear($event)\\\" class=\\\"btn btn-xs btn-link pull-right\\\"><i class=\\\"glyphicon glyphicon-remove\\\" aria-hidden=\\\"true\\\"></i></a></span></div>\");\r\n$templateCache.put(\"bootstrap/select-multiple.tpl.html\",\"<div class=\\\"ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control\\\" ng-class=\\\"{open: $select.open}\\\"><div><div class=\\\"ui-select-match\\\"></div><input type=\\\"text\\\" autocomplete=\\\"false\\\" autocorrect=\\\"off\\\" autocapitalize=\\\"off\\\" spellcheck=\\\"false\\\" class=\\\"ui-select-search input-xs\\\" placeholder=\\\"{{$selectMultiple.getPlaceholder()}}\\\" ng-disabled=\\\"$select.disabled\\\" ng-hide=\\\"$select.disabled\\\" ng-click=\\\"$select.activate()\\\" ng-model=\\\"$select.search\\\" role=\\\"combobox\\\" aria-label=\\\"{{ $select.baseTitle }}\\\" ondrop=\\\"return false;\\\"></div><div class=\\\"ui-select-choices\\\"></div></div>\");\r\n$templateCache.put(\"bootstrap/select.tpl.html\",\"<div class=\\\"ui-select-container ui-select-bootstrap dropdown\\\" ng-class=\\\"{open: $select.open}\\\"><div class=\\\"ui-select-match\\\"></div><input type=\\\"text\\\" autocomplete=\\\"false\\\" tabindex=\\\"-1\\\" aria-expanded=\\\"true\\\" aria-label=\\\"{{ $select.baseTitle }}\\\" aria-owns=\\\"ui-select-choices-{{ $select.generatedId }}\\\" aria-activedescendant=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\\\" class=\\\"form-control ui-select-search\\\" placeholder=\\\"{{$select.placeholder}}\\\" ng-model=\\\"$select.search\\\" ng-show=\\\"$select.searchEnabled && $select.open\\\"><div class=\\\"ui-select-choices\\\"></div></div>\");\r\n$templateCache.put(\"selectize/choices.tpl.html\",\"<div ng-show=\\\"$select.open\\\" class=\\\"ui-select-choices ui-select-dropdown selectize-dropdown single\\\"><div class=\\\"ui-select-choices-content selectize-dropdown-content\\\"><div class=\\\"ui-select-choices-group optgroup\\\" role=\\\"listbox\\\"><div ng-show=\\\"$select.isGrouped\\\" class=\\\"ui-select-choices-group-label optgroup-header\\\" ng-bind=\\\"$group.name\\\"></div><div role=\\\"option\\\" class=\\\"ui-select-choices-row\\\" ng-class=\\\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\\\"><div class=\\\"option ui-select-choices-row-inner\\\" data-selectable=\\\"\\\"></div></div></div></div></div>\");\r\n$templateCache.put(\"selectize/match.tpl.html\",\"<div ng-hide=\\\"($select.open || $select.isEmpty())\\\" class=\\\"ui-select-match\\\" ng-transclude=\\\"\\\"></div>\");\r\n$templateCache.put(\"selectize/select.tpl.html\",\"<div class=\\\"ui-select-container selectize-control single\\\" ng-class=\\\"{\\'open\\': $select.open}\\\"><div class=\\\"selectize-input\\\" ng-class=\\\"{\\'focus\\': $select.open, \\'disabled\\': $select.disabled, \\'selectize-focus\\' : $select.focus}\\\" ng-click=\\\"$select.activate()\\\"><div class=\\\"ui-select-match\\\"></div><input type=\\\"text\\\" autocomplete=\\\"false\\\" tabindex=\\\"-1\\\" class=\\\"ui-select-search ui-select-toggle\\\" ng-click=\\\"$select.toggle($event)\\\" placeholder=\\\"{{$select.placeholder}}\\\" ng-model=\\\"$select.search\\\" ng-hide=\\\"!$select.searchEnabled || ($select.selected && !$select.open)\\\" ng-disabled=\\\"$select.disabled\\\" aria-label=\\\"{{ $select.baseTitle }}\\\"></div><div class=\\\"ui-select-choices\\\"></div></div>\");\r\n$templateCache.put(\"select2/choices.tpl.html\",\"<ul class=\\\"ui-select-choices ui-select-choices-content select2-results\\\"><li class=\\\"ui-select-choices-group\\\" ng-class=\\\"{\\'select2-result-with-children\\': $select.choiceGrouped($group) }\\\"><div ng-show=\\\"$select.choiceGrouped($group)\\\" class=\\\"ui-select-choices-group-label select2-result-label\\\" ng-bind=\\\"$group.name\\\"></div><ul role=\\\"listbox\\\" id=\\\"ui-select-choices-{{ $select.generatedId }}\\\" ng-class=\\\"{\\'select2-result-sub\\': $select.choiceGrouped($group), \\'select2-result-single\\': !$select.choiceGrouped($group) }\\\"><li role=\\\"option\\\" id=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\\\" class=\\\"ui-select-choices-row\\\" ng-class=\\\"{\\'select2-highlighted\\': $select.isActive(this), \\'select2-disabled\\': $select.isDisabled(this)}\\\"><div class=\\\"select2-result-label ui-select-choices-row-inner\\\"></div></li></ul></li></ul>\");\r\n$templateCache.put(\"select2/match-multiple.tpl.html\",\"<span class=\\\"ui-select-match\\\"><li class=\\\"ui-select-match-item select2-search-choice\\\" ng-repeat=\\\"$item in $select.selected\\\" ng-class=\\\"{\\'select2-search-choice-focus\\':$selectMultiple.activeMatchIndex === $index, \\'select2-locked\\':$select.isLocked(this, $index)}\\\" ui-select-sort=\\\"$select.selected\\\"><span uis-transclude-append=\\\"\\\"></span> <a href=\\\"javascript:;\\\" class=\\\"ui-select-match-close select2-search-choice-close\\\" ng-click=\\\"$selectMultiple.removeChoice($index)\\\" tabindex=\\\"-1\\\"></a></li></span>\");\r\n$templateCache.put(\"select2/match.tpl.html\",\"<a class=\\\"select2-choice ui-select-match\\\" ng-class=\\\"{\\'select2-default\\': $select.isEmpty()}\\\" ng-click=\\\"$select.toggle($event)\\\" aria-label=\\\"{{ $select.baseTitle }} select\\\"><span ng-show=\\\"$select.isEmpty()\\\" class=\\\"select2-chosen\\\">{{$select.placeholder}}</span> <span ng-hide=\\\"$select.isEmpty()\\\" class=\\\"select2-chosen\\\" ng-transclude=\\\"\\\"></span> <abbr ng-if=\\\"$select.allowClear && !$select.isEmpty()\\\" class=\\\"select2-search-choice-close\\\" ng-click=\\\"$select.clear($event)\\\"></abbr> <span class=\\\"select2-arrow ui-select-toggle\\\"><b></b></span></a>\");\r\n$templateCache.put(\"select2/select-multiple.tpl.html\",\"<div class=\\\"ui-select-container ui-select-multiple select2 select2-container select2-container-multi\\\" ng-class=\\\"{\\'select2-container-active select2-dropdown-open open\\': $select.open, \\'select2-container-disabled\\': $select.disabled}\\\"><ul class=\\\"select2-choices\\\"><span class=\\\"ui-select-match\\\"></span><li class=\\\"select2-search-field\\\"><input type=\\\"text\\\" autocomplete=\\\"false\\\" autocorrect=\\\"off\\\" autocapitalize=\\\"off\\\" spellcheck=\\\"false\\\" role=\\\"combobox\\\" aria-expanded=\\\"true\\\" aria-owns=\\\"ui-select-choices-{{ $select.generatedId }}\\\" aria-label=\\\"{{ $select.baseTitle }}\\\" aria-activedescendant=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\\\" class=\\\"select2-input ui-select-search\\\" placeholder=\\\"{{$selectMultiple.getPlaceholder()}}\\\" ng-disabled=\\\"$select.disabled\\\" ng-hide=\\\"$select.disabled\\\" ng-model=\\\"$select.search\\\" ng-click=\\\"$select.activate()\\\" style=\\\"width: 34px;\\\" ondrop=\\\"return false;\\\"></li></ul><div class=\\\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\\\" ng-class=\\\"{\\'select2-display-none\\': !$select.open}\\\"><div class=\\\"ui-select-choices\\\"></div></div></div>\");\r\n$templateCache.put(\"select2/select.tpl.html\",\"<div class=\\\"ui-select-container select2 select2-container\\\" ng-class=\\\"{\\'select2-container-active select2-dropdown-open open\\': $select.open, \\'select2-container-disabled\\': $select.disabled, \\'select2-container-active\\': $select.focus, \\'select2-allowclear\\': $select.allowClear && !$select.isEmpty()}\\\"><div class=\\\"ui-select-match\\\"></div><div class=\\\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\\\" ng-class=\\\"{\\'select2-display-none\\': !$select.open}\\\"><div class=\\\"select2-search\\\" ng-show=\\\"$select.searchEnabled\\\"><input type=\\\"text\\\" autocomplete=\\\"false\\\" autocorrect=\\\"false\\\" autocapitalize=\\\"off\\\" spellcheck=\\\"false\\\" role=\\\"combobox\\\" aria-expanded=\\\"true\\\" aria-owns=\\\"ui-select-choices-{{ $select.generatedId }}\\\" aria-label=\\\"{{ $select.baseTitle }}\\\" aria-activedescendant=\\\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\\\" class=\\\"ui-select-search select2-input\\\" ng-model=\\\"$select.search\\\"></div><div class=\\\"ui-select-choices\\\"></div></div></div>\");}]);"],"sourceRoot":"/source/"}